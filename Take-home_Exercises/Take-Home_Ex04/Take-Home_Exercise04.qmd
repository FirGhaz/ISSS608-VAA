---
title: "Big Mac Index Choropleth and Trade Network Analysis"
subtitle: "Take Home Exercise 04"
author: "FirGhaz"
date: 02/03/2024
date modified: last modified
format:
  html:
    code-fold: true
    code-summary: "code block"
    code-tools: false
    code-copy: true
---

This exercise aims to develop a Shiny application featuring an interactive choropleth map to analyze global trade networks in conjunction with the Big Mac Index. By integrating geographical data with economic indicators, the application will enable a visual exploration of how trade volumes and net exports correlate with price parity across different regions. The choropleth will serve as a dynamic tool to observe patterns, offering users the ability to drill down into country-specific trade connections and Index values.

The final deliverable will be a user-centric Shiny application, optimized for engagement and insight discovery. It will be complemented by a concise report summarizing the analytical narratives that emerge from the visualization. This endeavor will not only underscore the practicality of geospatial data in economic analysis but also aims to enrich the discourse on the implications of trade dynamics for market pricing mechanisms like the Big Mac Index.

# 1 Load Packages

```{r}
#| warning: false 
library(tidyverse)
library(sf)
library(rnaturalearth)
library(countrycode)
library(ggrepel)
library(plotly)
library(cartogram)
library(ggforce)
```

# 2 EDA Trade on GEO

```{r}
#| warning: false 
worldly<- st_read("C:/FirGhaz/ISSS608-VAA/Take-home_Exercises/Take-Home_Ex04/data/geospatial/TM_WORLD_BORDERS-0.3.shp")
worldly_projected <- st_transform(worldly, "+proj=robin")  
data <- read_csv("C:/FirGhaz/ISSS608-VAA/Take-home_Exercises/Take-Home_Ex04/data/bmi_data_2021_carto.csv")
```

```{r}
#| warning: false 
map_pre <- worldly_projected%>%
  left_join(data)

clean <- data%>%
  select(iso_a3 ='ISO3',bmi_usd_price=bmi_usd_price, total_trade=total_trade, import_usd=import_usd, export_usd,)

# Join data to world map
map <- map_pre%>%
  left_join(clean)%>%
  select(-c(country, id, year, continent, iso_a3))%>%
  mutate(across(c(bmi_usd_price:population), ~ifelse(is.na(.), 0, .)))
  #drop_na(bmi_usd_price)

#st_write(map, "C:/FirGhaz/ISSS608-VAA/Take-home_Exercises/Take-Home_Ex04/data/map2021_data.csv")

ggplot(map, aes(fill=total_trade))+
  geom_sf() 
```

```{r}
#| warning: false 
dorl<-cartogram::cartogram_dorling(
  map, weight='total_trade', k = 3,
  m_weight = 1, itermax = 1000
)
# Set colors
col_world <- "#9CB4BF"
col_back <- "#1D201F"

# Set theme
theme_custom <- theme_void()+
  theme(plot.background = element_rect(fill=col_back,color=NA))

dorl<-dorl%>%
  mutate(
    # Compute area
    ar=as.numeric(st_area(dorl)),
    # Compute radius based on area
    rad=as.numeric(sqrt(ar/pi))
  )

# Extract centroids for each circle
centr <- dorl%>%
  st_centroid()%>%
  st_coordinates()

# Combine data
dorl2 <- tibble(dorl,X=centr[,1],Y=centr[,2])%>%
  arrange(-total_trade)

ggplot(map)+
  # World basemap
  geom_sf(
    worldly,mapping=aes(geometry=geometry),
    fill=col_world,color=alpha("dimgrey",0.25)
  )+
  # Draw Dorling cartogram with geom_circle()
  ggforce::geom_circle(
    data = dorl2, aes(x0 = X, y0 = Y, r = rad),
    fill=alpha("dimgrey",0.75),color=alpha("white",0.2)
  )+
  theme_custom
```

```{r}
#| warning: false 
dorl2 <- dorl2 %>%
  mutate(
    ratio_export = export_usd /total_trade,
    ratio_import = import_usd/total_trade
  )%>%
  mutate(
    rad_export=sqrt(rad*rad*ratio_export),
    rad_import=sqrt(rad*rad*ratio_import)
  )

col_export <- "#f2e901"
col_import <- "#FF4843"

ggplot(map)+
  # World basemap
  geom_sf(
    worldly,mapping=aes(geometry=geometry),
    fill=col_world,color=alpha("dimgrey",0.25)
  )+
  # Draw Dorling cartogram with geom_circle()
  ggforce::geom_circle(
    data = dorl2, aes(x0 = X, y0 = Y, r = rad),
    fill=alpha("dimgrey",0.75),color=alpha("white",0.2)
  )+
  # Draw circle for crops (or grass)
  ggforce::geom_circle(
    data = dorl2, aes(x0 = X, y0 = Y, r = rad_export),
    fill=col_export,color=NA
  )+
  theme_custom
```

```{r}
#| warning: false 
circleFun <- function(
    center=c(0,0),   # center of the circle 
    diameter=1,      # diameter 
    npoints=100,     # number of points to draw the circle
    start=0, end=2   # start point/end point
  ){
      tt <- seq(start*pi, end*pi, length.out=npoints)
      tb <- tibble(
        x = center[1] + diameter / 2 * cos(tt), 
        y = center[2] + diameter / 2 * sin(tt)
      )
    return(tb)
}

half_export <- bind_cols(
  ISO3 = rep(dorl2$ISO3[1],100),
  circleFun(
    c(dorl2$X[1],dorl2$Y[1]),dorl2$rad_export[1]*2, start=1.5, end=2.5
  ))

half_import <- bind_cols(
  ISO3 = rep(dorl2$ISO3[1],100),
  circleFun(
    c(dorl2$X[1],dorl2$Y[1]),dorl2$rad_import[1]*2, start=0.5, end=1.5
  ))

col_world <- "#9CB4BF"
col_back <- "#1D201F"

# Set theme
theme_custom <- theme_void()+
  theme(plot.background = element_rect(fill=col_back,color=NA))



# Make loop for all countries
for (i in 2:dim(dorl2)[1]){

  # Draw for exports
  temp_export <- bind_cols(
    ISO3 = rep(dorl2$ISO3[i],100),
    circleFun(
      c(dorl2$X[i],dorl2$Y[i]),dorl2$rad_export[i]*2, start=1.5, end=2.5
    ))
  # Draw for imports
  temp_import <- bind_cols(
    ISO3 = rep(dorl2$ISO3[i],100),
    circleFun(
      c(dorl2$X[i],dorl2$Y[i]),dorl2$rad_import[i]*2, start=0.5, end=1.5
    ))
  
  half_export<-half_export%>%
    bind_rows(temp_export)
  
  half_import<-half_import%>%
    bind_rows(temp_import)
}
df <- data.frame(
  x = 1:3,
  y = c(3, 2, 1),
  group = c("A", "B", "C")
)

# Make map
p <- ggplot(map)+
  # World basemap
  geom_sf(
    worldly,mapping=aes(geometry=geometry),
    fill=col_world,color=alpha("dimgrey",0.25)
    
  )+
  # Draw Dorling cartogram with geom_circle()
  ggforce::geom_circle(
    data = dorl2, aes(x0 = X, y0 = Y, r = rad),
    fill=alpha("dimgrey",0.75),color=alpha("white",0.2)
  )+
  # Draw half circle for crop with geom_polygon
  geom_polygon(
    half_export,
    mapping=aes(x,y,group=ISO3),
    fill=col_export,color=NA
  )+ 
  # Draw half circle for grass with geom_polygon
  geom_polygon(
    half_import,
    mapping=aes(x,y,group=ISO3),
    fill=col_import,color=NA
  )+ 
  theme_custom

x_range <- range(dorl2$X, na.rm = TRUE)
y_range <- range(dorl2$Y, na.rm = TRUE)
# Calculate positions for legend items based on the range
legend_x <- x_range[1] * 1.20 # Place legend slightly to the right of the X range minimum
legend_y_total_trade <- y_range[1] * 1.15 # Start legend slightly above the Y range minimum
legend_y_exports <- legend_y_total_trade + abs(y_range[2] - y_range[1]) * 0.05 # 5% above total trade
legend_y_imports <- legend_y_exports + abs(y_range[2] - y_range[1]) * 0.05

p +  annotate("point", x = legend_x, y = legend_y_total_trade, shape = 21, size = 12, fill = "dimgrey", colour = "dimgrey" ) +
  annotate("text", x = legend_x + 1, y = legend_y_total_trade, label = "Total Trade         1 billion(US)", hjust = 0.52, vjust = 1.6, colour = "grey", size=3.7, fontface = "italic", family = "Arial" ) +
  annotate("text", x = legend_x + 1, y = legend_y_exports, label = "Exports", hjust = 1.8, vjust = 1.2, colour = "#f2e901", size=3.7,fontface = "italic", family = "Arial") +
  annotate("text", x = legend_x + 1, y = legend_y_imports, label = "Imports", hjust = 1.8, vjust = 0.8, colour = "#FF4843", size=3.7, fontface = "italic", family = "Arial") +
  annotate("text", x = legend_x + 1, y = legend_y_imports, label = "Trade 2021", hjust = 1.16, vjust = -0.5, colour = "white", size=4.5, fontface = "bold", family = "Arial") +
  theme_custom
```

```{r}
#| warning: false 
bmi_node_2021 <- read.csv('C:/FirGhaz/ISSS608-VAA/Take-home_Exercises/Take-Home_Ex04/data/bmi_node_2021_add.csv')
bmi_edges_2021 <- read.csv('C:/FirGhaz/ISSS608-VAA/Take-home_Exercises/Take-Home_Ex04/data/import_export_beef_edges5-2021.csv')
```

```{r}
#| warning: false 

library(sf)
library(ggplot2)
library(ggforce) 
library(maps) 
library(geosphere)

# Assuming 'bmi_node_2021' is your dataframe and it has columns 'LON' and 'LAT'
# Make sure 'bmi_node_2021' is a data frame and 'LON' and 'LAT' are not factors
bmi_node_2021a <- data.frame(bmi_node_2021)
bmi_node_2021a$LON <- as.numeric(as.character(bmi_node_2021a$LON))
bmi_node_2021a$LAT <- as.numeric(as.character(bmi_node_2021a$LAT))

# Convert your data frame to an sf object
node_sf <- st_as_sf(bmi_node_2021a, coords = c("LON", "LAT"), crs = 4326)
node_sf_projected <- st_transform(node_sf, st_crs(worldly_projected))


bmi_edges_2021$source_lon <- as.numeric(bmi_edges_2021$source_lon)
bmi_edges_2021$source_lat <- as.numeric(bmi_edges_2021$source_lat)
bmi_edges_2021$target_lon <- as.numeric(bmi_edges_2021$target_lon)
bmi_edges_2021$target_lat <- as.numeric(bmi_edges_2021$target_lat)

col_world <- "#9CB4BF"
col_back <- "#1D201F"

# Set theme
theme_custom <- theme_void()+
  theme(plot.background = element_rect(fill=col_back,color=NA))

# Create a LINESTRING for each row in bmi_edges_2021
edges_linestrings <- lapply(1:nrow(bmi_edges_2021), function(i) {
  row <- bmi_edges_2021[i, ]
  st_linestring(matrix(c(row$source_lon, row$source_lat, row$target_lon, row$target_lat), ncol = 2, byrow = TRUE))
})

# Convert the list of LINESTRINGs to an sf object
edges_sf <- st_sfc(edges_linestrings, crs = 4326)

# Convert to a data frame structure for sf, if needed
edges_sf_df <- st_sf(geometry = edges_sf)

# Transform to the same CRS as the base map
edges_sf_projected <- st_transform(edges_sf_df, st_crs(worldly_projected))



col.1 <- adjustcolor("orangered", alpha=0.02)
col.2 <- adjustcolor("yellow", alpha=0.02)
edge.pal <- colorRampPalette(c(col.1, col.2), alpha = TRUE)

# Assuming 'Weight' is normalized between 0 and 1 for color mapping
max_weight <- max(bmi_edges_2021$Value, na.rm = TRUE)
edge.col <- edge.pal(1000000)[round(1000000 * bmi_edges_2021$Value / max_weight)]

# Generate arc data
arc_data <- lapply(1:nrow(bmi_edges_2021), function(i) {
  row <- bmi_edges_2021[i,]
  arc <- gcIntermediate(
    c(row$source_lon, row$source_lat),
    c(row$target_lon, row$target_lat),
    n=300, addStartEnd=TRUE, breakAtDateLine=F
  )
  data.frame(lon = arc[,1], lat = arc[,2], weight = row$Value, edge_col = edge.col[i])
}) %>%
  do.call(rbind, .)

# Convert arc data to an sf object and project
arc_sf <- st_as_sf(arc_data, coords = c("lon", "lat"), crs = 4326)
arc_sf_projected <- st_transform(arc_sf, st_crs(worldly_projected))


p <- ggplot(map) +
  geom_sf(data = worldly_projected, fill = col_world, color = alpha("dimgrey", 0.25)) +
  geom_sf(data = node_sf_projected, aes(geometry = geometry), color = "red", size = 1) + 
  geom_sf(data = arc_sf_projected, aes(color = edge_col), size = 0.0001) +  # Assuming 'edge_col' is part of 'arc_sf_projected'
  scale_color_identity() +

  # Draw Dorling cartogram with geom_circle()
  ggforce::geom_circle(
    data = dorl2, aes(x0 = X, y0 = Y, r = rad),
    fill=alpha("dimgrey",0.75),color=alpha("white",0.2)
  )+
  # Draw half circle for crop with geom_polygon
  geom_polygon(
    half_export,
    mapping=aes(x,y,group=ISO3),
    fill=col_export,color=NA
  )+ 
  # Draw half circle for grass with geom_polygon
  geom_polygon(
    half_import,
    mapping=aes(x,y,group=ISO3),
    fill=col_import,color=NA
  )+ 
  theme_custom

x_range <- range(dorl2$X, na.rm = TRUE)
y_range <- range(dorl2$Y, na.rm = TRUE)
# Calculate positions for legend items based on the range
legend_x <- x_range[1] * 1.20 # Place legend slightly to the right of the X range minimum
legend_y_total_trade <- y_range[1] * 1.15 # Start legend slightly above the Y range minimum
legend_y_exports <- legend_y_total_trade + abs(y_range[2] - y_range[1]) * 0.05 # 5% above total trade
legend_y_imports <- legend_y_exports + abs(y_range[2] - y_range[1]) * 0.05

p + annotate("point", x = legend_x, y = legend_y_total_trade, shape = 21, size = 8, fill = "dimgrey", colour = "dimgrey" ) +
  annotate("text", x = legend_x + 1, y = legend_y_total_trade, label = "Total Trade     1 billion(US)", hjust = 0.52, vjust = 1.6, colour = "grey", size=3.5, fontface = "italic", family = "Arial" ) + 
  annotate("text", x = legend_x + 1, y = legend_y_total_trade, label = "Beef Trade --", hjust = 1.07, vjust = 2.9, colour = "orangered", size=3.5, fontface = "italic", family = "Arial" ) +
  annotate("text", x = legend_x + 1, y = legend_y_exports, label = "Exports", hjust = 1.8, vjust = 1.2, colour = "#f2e901", size=3.5,fontface = "italic", family = "Arial") +
  annotate("text", x = legend_x + 1, y = legend_y_imports, label = "Imports", hjust = 1.8, vjust = 0.8, colour = "#FF4843", size=3.5, fontface = "italic", family = "Arial") +
  annotate("text", x = legend_x + 1, y = legend_y_imports, label = "Trade Network 2021", hjust = 0.58, vjust = -0.4, colour = "white", size=4.3, fontface = "italic", family = "Arial") +
  
theme_custom
```

# 3 Visualising the Network: Exploratory Data Analysis

Emphasis here is to give them the option to play with the nodes, layout and geom_edge functions.

```{r}
#| warning: false 
library(tidygraph)
library(igraph)
library(ggplot2)
library(ggraph)
library(visNetwork) 
```

```{r}
#| warning: false
bmi2021_graph <- tbl_graph(nodes = bmi_node_2021,
                           edges = bmi_edges_2021, 
                            directed = TRUE)
```

```{r}
#| warning: false 

#this are the node attributes
V(bmi2021_graph)$bmi_usd_price <- bmi_node_2021$bmi_usd_price
V(bmi2021_graph)$gdp_per_capita<- bmi_node_2021$gdp_per_capita
V(bmi2021_graph)$inflation <- bmi_node_2021$inflation

ggraph(bmi2021_graph, layout = "kk") + #layout options = kk, fr, nicely,
  geom_node_point(aes(fill = V(bmi2021_graph)$bmi_usd_price , size = V(bmi2021_graph)$bmi_usd_price, color = continent, show.legend=FALSE),
                  
                  )+
  geom_edge_link2(aes(color = Trade, width = Value), alpha = 0.6, show.legend=FALSE) + 
  scale_edge_color_manual(values = c("Import Quantity" = "#00CCB0", "Export Quantity" = "#FF6ABE")) +
  scale_edge_width(range = c(0.5, 4)) +
  geom_node_text(aes(label = country), repel = TRUE, size = 2, hjust = 0.6, vjust = -1.8, color = "white") +
  theme_graph(background = '#1D201F', text_colour = 'white') +
  guides(color = guide_legend(title = "Type"),
         edge_width = guide_legend(override.aes = list(color = "white")))
  coord_fixed() 

```

```{r}
library(visNetwork)
library(htmlwidgets)

nodes_data <- data.frame(id = V(bmi2021_graph)$country, 
                         label = V(bmi2021_graph)$country,
                         value = V(bmi2021_graph)$bmi_usd_price, #to change to inflation, gdp
                         group = V(bmi2021_graph)$continent,
                         title = paste("<b>BMI:</b>", V(bmi2021_graph)$bmi_usd_price,
                                       "<br><b>GDP:</b>", V(bmi2021_graph)$gdp_per_capita,
                                       "<br><b>Inf:</b>", V(bmi2021_graph)$inflation))

# Create a data frame for edges that visNetwork can use
edges_data <- data.frame(from = bmi_edges_2021$Origin, 
                         to = bmi_edges_2021$Partners,
                         value = bmi_edges_2021$Value,
                         title = bmi_edges_2021$Trade,
                         arrows = 'to')

# Now let's create the visNetwork graph
network <- visNetwork(nodes_data, edges_data, width = "100%", height = "400px") %>%
  visNodes(size = "bmi_usd_price", shadow = TRUE,
           color = list(background = "white", border = "#2B7CE9"),
           font = list(color = "white")) %>%
  visEdges(smooth = FALSE, color = list(color = "#A5ABB6", highlight = "#FF4F09")) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLegend() %>%
  visInteraction(navigationButtons = TRUE) %>%
  visLayout(randomSeed = 123)


# Add custom CSS to change the background color
network <- network %>% 
  htmlwidgets::onRender("
    function(el, x) {
      el.style.backgroundColor = 'black';
    }
  ")

# Print the network to display it
network
```


## 3.1 Network Centrality and Community Clustering

For our scope of the project, we will select 50+ countries with (1) significant trade activities and (2) complete data together with BMI(Index). A *Trade Connectivity Index (TCI)* will be calculated for each edge in the network will be calculated as follows:

![](images/TCI.png){width="305"}

**Edge Weight Formula: Trade Connectivity Index (TCI)**

This formula reflects the proportion of beef trade (exports and imports) in relation to the total trade volume between two countries. It highlights the significance of beef trade in the bilateral trade relationship, making it particularly relevant for analysing the trade networks with respect to the Big Mac Index. Hence, this will be applied to our network edges.

-   **Beef Exports Value** and **Beef Imports Value** refer to the value of beef traded between the two countries forming an edge in the network.

-   **Total Exports Value** and **Total Imports Value** encompass the total trade volume between these countries, providing a base to understand the relative importance of beef trade.

**Node Attributes**

For the nodes, you can maintain attributes that reflect each country's economic and demographic scale, as well as its relevance to the Big Mac Index:

-   **BMI Index**: Directly use the Big Mac Index as a node attribute to represent the pricing level of a Big Mac, serving as a proxy for purchasing power parity.

-   **Trade Value**: This could be represented by either Total Exports or Total Imports to reflect the country's engagement in global trade. Alternatively, you might use a composite measure such as GDP to reflect overall economic size and capacity.

We will compute the centrality and community clusters to determine their community clusters

In our exploration of global trade dynamics, specifically through the lens of beef exports and imports, we aim to uncover insights into the Big Mac Index, a whimsical gauge of purchasing power parity devised by The Economist. Analyzing beef trade patterns grants us a direct line of inquiry into the pricing mechanisms of the Big Mac, considering beef's pivotal role in its composition. This focus allows us to parse the supply chain intricacies and market conditions that dictate the variability in Big Mac prices across different regions. The rationale behind this targeted analysis is to use beef trade as a tangible metric for understanding broader economic trends and pricing pressures that ultimately influence consumer goods' costs.

To navigate this complex interplay, we've adopted a formula integrating critical trade data and economic indicators to model their relationship with the Big Mac Index. This formula captures the essence of trade balance, economic scale (granular and macro at the same time), and the specific impact of beef trade. It correlates net exports relative to GDP per capita with the proportions of beef exports and imports within total trade, providing a nuanced perspective on how trade dynamics influence market conditions and, by extension, Big Mac prices.

## 3.2 Computing Centrality

```{r}
#| warning: false 
library(ggraph)
library(igraph)


bmi2021_graph <- igraph::set_vertex_attr(bmi2021_graph, "betweenness", value = igraph::betweenness(bmi2021_graph))


g <- ggraph(bmi2021_graph, layout = "fr") +
  geom_edge_link(aes(width = Value), alpha = 0.5) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(size = betweenness), color = "black") +
  geom_node_text(aes(label = country), repel = TRUE, size = 2, hjust = 0.6, vjust = -1.8, color = "black") +
  theme_graph()


g <- g + geom_node_point(aes(color = continent))


g

```

**Degree Centrality** Degree centrality measures the number of edges connected to a node. In directed networks, you can distinguish between in-degree and out-degree.

Degree centrality is a measure used in network analysis to quantify the importance or influence of a particular node within a network. It is based on the number of connections, or edges, that a node has to other nodes. The central concept behind degree centrality is simple: nodes with more connections are considered more central and potentially more influential within the network.

There are two types of degree centrality:

In-Degree Centrality: This measures the number of incoming connections to a node. It can be particularly relevant in directed networks where the direction of the connection matters. A high in-degree centrality indicates that a node is a major target within the network, receiving many connections from other nodes. This can signify a node of high interest or popularity.

Out-Degree Centrality: This measures the number of outgoing connections from a node. Like in-degree centrality, it is applicable in directed networks. A high out-degree centrality signifies that a node actively reaches out to many other nodes, which can indicate a source or distributor of information, goods, or influence within the network

```{r}
#| warning: false 
#| echo: false
library(ggraph)
library(igraph)

# Assuming bmi2021_graph is an igraph object
# Compute degree centrality and add it to the graph object
bmi2021_graph <- igraph::set_vertex_attr(bmi2021_graph, "degree", value = igraph::degree(bmi2021_graph))

# Plotting the graph with ggraph
g <- ggraph(bmi2021_graph, layout = "fr") +
  geom_edge_link(aes(width = Value), alpha = 0.5) + 
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(size = degree, color = continent)) + # Size nodes by degree centrality and color by continent
  geom_node_text(aes(label = country), repel = TRUE, size = 2, hjust = 0.5, color = "black", fontface = "bold") +
  theme_graph() +
  scale_size_continuous(range = c(1, 10)) + # Adjust the range for the size of the nodes
  labs(size = "Degree Centrality") # Label for the size scale

# Display the graph
g

```

Degree centrality is a straightforward but powerful concept in network analysis, useful for identifying key nodes that might play critical roles in the dissemination of information, disease transmission, social network influence, and more within a network.

**Eigenvector Centrality** Eigenvector centrality measures a node's influence based on the principle that connections to high-scoring nodes contribute more to the score of the node in question.

```{r}
#| warning: false 
#| echo: false
eigenvector_centrality <- eigen_centrality(bmi2021_graph)$vector

print(summary(eigenvector_centrality))

V(bmi2021_graph)$eigenvector <- eigenvector_centrality

print(head(V(bmi2021_graph)$eigenvector))

```

```{r}
#| warning: false 
#| echo: false
# Now, use ggraph to visualize the network
g_eigen <- ggraph(bmi2021_graph, layout = "fr") + 
  geom_edge_link(aes(width = Value), alpha = 0.5) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(size = eigenvector, color = continent)) +
  geom_node_text(aes(label = country), repel = TRUE, size = 3, color = "black") +
  theme_graph() +
  scale_size_continuous(name = "Eigenvector Centrality") +
  guides(color = guide_legend("Continent"))

# Print the graph with eigenvector centrality
print(g_eigen)
```

Eigenvector centrality is useful for identifying influential nodes in a network where connections to high-scoring nodes contribute more to the score of the node than equal connections to low-scoring nodes.

**Closeness centrality**

```{r}
#| warning: false 
#| echo: false
library(igraph)

# Assuming bmi2021_graph is your igraph graph object
V(bmi2021_graph)$closeness <- closeness(bmi2021_graph)

# Visualize the network with closeness centrality
g_closeness <- ggraph(bmi2021_graph, layout = "fr") + 
  geom_edge_link(aes(width = Value), alpha = 0.5) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(size = closeness, color = continent), alpha = 0.7) +
  geom_node_text(aes(label = country), repel = TRUE, size = 2) +
  theme_graph() +
  scale_size_continuous(name = "Closeness Centrality") + 
  guides(color = guide_legend(title = "Continent"))

# Print the graph with closeness centrality
print(g_closeness)

```

Putting the results in a dataframe.

```{r}
#| warning: false 
#| echo: false
library(igraph)
library(dplyr)

degree_centrality <- degree(bmi2021_graph)
betweenness_centrality <- betweenness(bmi2021_graph)
closeness_centrality <- closeness(bmi2021_graph)
eigenvector_centrality <- eigen_centrality(bmi2021_graph)$vector

centrality_measures <- data.frame(
  node = V(bmi2021_graph)$country,  # or use V(bmi2021_graph)$name if nodes are named
  degree = degree_centrality,
  betweenness = betweenness_centrality,
  closeness = closeness_centrality,
  eigenvector = eigenvector_centrality
)



centrality_measures_arranged <- centrality_measures %>%
  arrange(desc(degree)) 



```

In the Shiny App, we will allow the audience to explore these statistical methods to gain insights from the networks.

| Betweenness                                                                                                                                                                                                | Degree                                                                                                                                                                       | EigenVector                                                                                                                                                                                                                                                   | Closeness                                                                                                                                                                                           |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Nodes like the United States and Brazil have high betweenness centrality, suggesting that they act as significant connectors or bridges within the network, **potentially controlling the flow of trade.** | Nodes such as the United States and Brazil have high degrees, meaning they have numerous trade connections, possibly making them **central hubs in the beef trade network.** | The eigenvector centrality considers not just the number but the quality of connections. Nodes with high eigenvector centrality, like the **United States and Australia, are connected to other well-connected nodes, hinting at influential trade cliques.** | High closeness centrality for nodes like the United States and South Africa suggests that they can quickly interact or trade with all other nodes, indicating efficiency in their trade operations. |
| Some countries much higher centrality, which could mean **the trade network relies heavily on these nodes**, possibly creating vulnerability to disruptions.                                               | Degree centrality can suggest potential market influence, with highly connected nodes being able to leverage their position for competitive advantage.                       | This measure reflects the potential for a node to access and influence the broader network through its connections.                                                                                                                                           | Closeness centrality offers insight **into the speed at which a country** can react to supply and demand changes across the global network                                                          |
| Countries with lower betweenness centrality might have more **direct trade links or may not be critical transit points within the network.**                                                               | A spread of degree centrality across the network would indicate a democratized trading environment, but a concentration suggests a few key players dominate.                 | Low eigenvector centrality could indicate peripheral or less influential roles within the trading network, possibly **representing newer or more specialized markets**.                                                                                       | Low closeness centrality might point to **potential delays in trade flows or inefficiencies,** possibly due to geographical or logistical factor                                                    |

:::callout: Summary of Insights 1. Network Roles and Big Mac Pricing:

Countries central in the beef trade network, indicated by high betweenness or degree centrality, may have more stable and competitive beef pricing due to their numerous trade links, which could affect their local Big Mac prices. The presence of key influencers, as suggested by eigenvector centrality, could indicate the potential for price setting or market influence, which can trickle down to the pricing of beef and related products like the Big Mac.

2.  Trade Efficiency and Cost:

Closeness centrality can signal efficient trade practices and the potential for rapid adjustment to market changes, which could lead to more competitive and stable pricing for beef, affecting the Big Mac Index. Any delays or inefficiencies in beef imports could increase costs for local producers, potentially raising Big Mac prices in countries with lower closeness centrality.

3.  Cluster Analysis and Market Groupings:

Clustering helps identify groups of countries with similar trade patterns, which can show regional variations in Big Mac prices due to similarities in trade dynamics and economic profiles. Understanding these clusters can provide insights into regional pricing strategies for the Big Mac and indicate how economic or trade changes in one country might impact others within the same cluster. :::

## 3.3 Computing Community Indices

Tidygraph package inherits many of the community detection algorithms imbedded into igraph We will utilise 3 community detection algo: (1) Leading eigenvector (group_leading_eigen), (2) Walktrap and (3) Spinglass (group_spinglass).Some community algorithms are designed to take into account direction or weight, while others ignore it.

**group_leading Eigenvector**

```{r}
#| warning: false 

g <- bmi2021_graph %>%
  mutate(community = as.factor(group_leading_eigen(weights = Value))) %>%
  ggraph(layout = "fr") + 
  geom_edge_link(aes(width = Value), alpha = 0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = community), size = 3) +
  theme_graph()
```

```{r}
#| warning: false 

library(igraph)
library(visNetwork)


communities <- cluster_leading_eigen(bmi2021_graph, weights = E(bmi2021_graph)$Value)

# Add community info to the nodes dataframe
bmi_node_2021$community <- communities$membership

# Ensure 'id' column for joining and 'label' for visNetwork node labels
bmi_node_2021$label <- bmi_node_2021$country

bmi_node_2021$community <- as.factor(bmi_node_2021$community)

num_communities <- length(unique(bmi_node_2021$community))

# Generate a color for each community
# Use colorRampPalette to create more colors if needed
color_palette <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_communities), name = "Set1"))
community_colors <- color_palette(num_communities)

# Map community IDs to colors
color_mapping <- setNames(community_colors, levels(bmi_node_2021$community))
bmi_node_2021$color <- color_mapping[bmi_node_2021$community]

bmi_edges_2021_aggregated <- bmi_edges_2021 %>%
  left_join(bmi_node_2021, by = c("Origin" = "country")) %>%
  rename(from = id) %>%
  left_join(bmi_node_2021, by = c("Partners" = "country")) %>%
  rename(to = id) %>%
   group_by(from, to) %>%
    summarise(Value = n()) %>%
 filter(from!=to) %>%
  #filter(Value > 1) %>%
  ungroup()
bmi_node_2021$label <- bmi_node_2021$country

# Create the network visualization
visNetwork(nodes = bmi_node_2021, edges = bmi_edges_2021_aggregated) %>%
  visIgraphLayout(layout = "layout_nicely") %>%
  visNodes(aes(color = "community"), shape = "dot", scaling = list(label = list(enabled = TRUE)),
           font = list(size = 35, face = "arial", color = "#000000", bold = "true")) %>%
  visEdges(arrows = "to") %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = 123) %>%
  visLegend()

```

**WalkTrap** The Walktrap algorithm is another method for detecting communities in graphs. It attempts to find densely connected subgraphs (communities) in a graph based on random walks. The idea is that short random walks tend to stay in the same community.

```{r}
#| warning: false 
#| echo: false
library(tidygraph)
library(ggraph)

# Ensure bmi2021_graph is a tbl_graph; if it's an igraph object, convert it
bmi2021_graph_tbl <- as_tbl_graph(bmi2021_graph)

g <- bmi2021_graph_tbl %>%
  mutate(community = as.factor(group_walktrap())) %>%
  ggraph(layout = "fr") + 
  geom_edge_link(aes(width = Value), alpha = 0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = community)) +
  theme_graph()

g

```

```{r}
#| warning: false 
#| echo: false
library(igraph)
library(visNetwork)

# Perform Walktrap community detection
communities_walktrap <- cluster_walktrap(bmi2021_graph, weights = E(bmi2021_graph)$Value)

# Add community info to the nodes data frame
bmi_node_2021$community <- communities_walktrap$membership

# Convert community IDs to a factor
bmi_node_2021$community <- as.factor(bmi_node_2021$community)

# Generate a color for each community
num_communities <- length(unique(bmi_node_2021$community))
color_palette <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_communities), "Set1"))
community_colors <- color_palette(num_communities)
color_mapping <- setNames(community_colors, levels(bmi_node_2021$community))
bmi_node_2021$color <- color_mapping[bmi_node_2021$community]

# Ensure 'id' column for joining and 'label' for visNetwork node labels
bmi_node_2021$label <- bmi_node_2021$country

# Preparing edges data frame for visNetwork
bmi_edges_2021_aggregated <- bmi_edges_2021 %>%
  left_join(bmi_node_2021, by = c("Origin" = "country")) %>%
  rename(from = id) %>%
  left_join(bmi_node_2021, by = c("Partners" = "country")) %>%
  rename(to = id) %>%
  group_by(from, to) %>%
  summarise(Value = n()) %>%
  filter(from != to) %>%
  ungroup()

# Create the network visualization with visNetwork
visNetwork(nodes = bmi_node_2021, edges = bmi_edges_2021_aggregated) %>%
  visIgraphLayout(layout = "layout_nicely") %>%
  visNodes(color = "color", shape = "dot", label = "label", scaling = list(label = list(enabled = TRUE)), font = list(size = 35, face = "arial", color = "#000000", bold = "true")) %>%
  visEdges(arrows = "to") %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLegend() %>%
  visLayout(randomSeed = 123)

```

**Spinglass**

```{r}
#| warning: false 

g <- bmi2021_graph %>%
  mutate(community = as.factor(group_spinglass(weights = Value))) %>%
  ggraph(layout = "fr") + 
  geom_edge_link(aes(width = Value), alpha = 0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = community)) +
  theme_graph()

g
```

```{r}
#| warning: false 

library(igraph)

# Perform Spinglass community detection
communities_spinglass <- cluster_spinglass(bmi2021_graph, weights = E(bmi2021_graph)$weight)

# Add community info to the nodes dataframe
bmi_node_2021$community <- communities_spinglass$membership

# Ensure 'id' column for joining and 'label' for visNetwork node labels
bmi_node_2021$label <- bmi_node_2021$country

bmi_node_2021$community <- as.factor(bmi_node_2021$community)

num_communities <- length(unique(bmi_node_2021$community))

# Generate a color for each community
# Use colorRampPalette to create more colors if needed
color_palette <- colorRampPalette(RColorBrewer::brewer.pal(min(9, num_communities), name = "Set1"))
community_colors <- color_palette(num_communities)

# Map community IDs to colors
color_mapping <- setNames(community_colors, levels(bmi_node_2021$community))
bmi_node_2021$color <- color_mapping[bmi_node_2021$community]

bmi_edges_2021_aggregated <- bmi_edges_2021 %>%
  left_join(bmi_node_2021, by = c("Origin" = "country")) %>%
  rename(from = id) %>%
  left_join(bmi_node_2021, by = c("Partners" = "country")) %>%
  rename(to = id) %>%
   group_by(from, to) %>%
    summarise(Value = n()) %>%
 filter(from!=to) %>%
  #filter(Value > 1) %>%
  ungroup()
bmi_node_2021$label <- bmi_node_2021$country

# Create the network visualization
visNetwork(nodes = bmi_node_2021, edges = bmi_edges_2021_aggregated) %>%
  visIgraphLayout(layout = "layout_nicely") %>%
  visNodes(aes(color = "community"), shape = "dot", scaling = list(label = list(enabled = TRUE)),
           font = list(size = 35, face = "arial", color = "#000000", bold = "true")) %>%
  visEdges(arrows = "to") %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = 123) %>%
  visLegend()

```

::: Callout:Insights
1.  Leading Eigenvector

Insight: This method often identifies communities based on the influence of nodes. Nodes with high eigenvector centrality are connected to other influential nodes, which can form a community. Implication for Big Mac Index: Communities identified by the Leading Eigenvector method might represent countries with influential trade relationships or economic ties that can impact the Big Mac Index through pricing standards, trade agreements, or shared economic policies.

2.  Walktrap

Insight: Walktrap finds communities by simulating random walks on the network, with the idea that walks are "trapped" within densely connected parts of the graph. Implication for Big Mac Index: The communities detected could reflect clusters of countries where trade flow is more frequent or robust, possibly due to geographic proximity or trade agreements, which in turn may affect the local pricing strategies included in the Big Mac Index.

3.  Spinglass

Insight: This method uses a spin model from statistical mechanics and is particularly good at detecting community structures where communities may be hierarchically nested. Implication for Big Mac Index: Spinglass communities may reflect complex and layered trade relationships, possibly uncovering hierarchies in economic interactions that could influence the Big Mac Index.

4.  Comparison Summary:

The Leading Eigenvector method might highlight dominant countries in trade that potentially set benchmarks for the Big Mac Index. The Walktrap method may reveal more about regional trading blocks or groups of countries with stronger internal trade links that could have similar Big Mac pricing due to shared market conditions. The Spinglass method can uncover more nuanced and multi-level communities, possibly highlighting intricate trade relationships and their cascading effects on the Big Mac Index.
:::
